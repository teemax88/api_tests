# n = 26670
# max_n = 0
# min_n = 9
# while n > 0:
#     if n % 10 > max_n:
#         max_n = n % 10
#     if n % 10 < min_n:
#         min_n = n % 10
#     n = n // 10
#
# print(f'Максимальная цифра равна {max_n}')
# print(f'Минимальная цифра равна {min_n}')

"""/////////////////////////////////*************************************////////////////////////////////////"""

# fib = lambda x: 1 if x <= 2 else fib(x - 1) + fib(x - 2)
# print(fib(31))

"""/////////////////////////////////*************************************////////////////////////////////////"""

# count_num = int(input())
# sum = 0
# while count_num != 0:
#     n = int(input())
#     sum += n
#     count_num -= 1
#
# print(sum)

"""/////////////////////////////////*************************************////////////////////////////////////"""

# x = [1, 2, 3]
# print(id(x))    # 2354664526528
# print(id([1, 2, 3]))    # 2354666371328
# print(id(x) == id([1, 2, 3]))   # False
# y = x
# print(id(y))    # 2354664526528
# print(id(x) == id(y))   # True
# x.append(4)
# print(x)    # [1, 2, 3, 4]
# print(y)    # [1, 2, 3, 4]
# print(x is y)   # True

"""/////////////////////////////////*************************************////////////////////////////////////"""

x = [1, 2, 3]
y = x
y.append(4)
print(y)  # [1, 2, 3, 4]
print(x)  # [1, 2, 3, 4]

s = "123"
t = s
print(t)  # 123
print(s)  # 123
t = t + "4"
print(t)  # 1234
print(s)  # 123

print(str(x) + " " + s)

"""/////////////////////////////////*************************************////////////////////////////////////"""

"""Полиморфизм — это способность объекта принимать различные формы. В ООП
полиморфизм позволяет писать код, который может работать с объектами разных
классов, если они имеют общий интерфейс или базовый класс."""


# Перегрузка методов
# позволяет определить несколько методов с одинаковым именем, но разными параметрами
class Math:
    def add(self, a, b):
        return a + b

    def add(self, a, b, c):
        return a + b + c


# Например, вы можете написать функцию, которая принимает в качестве
# аргумента объект класса Animal и вызывает метод speak на этом объекте. Затем
# вы можете передать в функцию объекты классов Dog и Cat, и в зависимости от
# типа переданного объекта будет вызван соответствующий метод speak.


class Animal:
    def speak(self):
        print("The animal makes a sound")


class Dog(Animal):
    def speak(self):
        print("The dog barks")


class Cat(Animal):
    def speak(self):
        print("The cat meows")


def make_sound(animal):
    animal.speak()


dog = Dog()
cat = Cat()
make_sound(dog)
make_sound(cat)

"""/////////////////////////////////*************************************////////////////////////////////////"""

# Абстрактные классы и интерфейсы


"""/////////////////////////////////*************************************////////////////////////////////////"""

# Абстракция данных и инкапсуляция данных


"""/////////////////////////////////*************************************////////////////////////////////////"""


# Перегрузка операторов

# это возможность переопределения
# действий оператора при его применении к экземпляру класса. Например, если
# вы добавите пользовательский класс для представления комплексных чисел, то
# можете определить, что произойдет, когда оператор + будет использоваться для
# сложения двух экземпляров вашего класса

# Пример
class ComplexNumber:
    def __init__(self, real, imaginary):
        self.real = real
        self.imaginary = imaginary

    def __add__(self, other):
        return ComplexNumber(self.real + other.real, self.imaginary + other.imaginary)

    def __str__(self):
        return f"{self.real} + {self.imaginary}i"


a = ComplexNumber(1, 3)
b = ComplexNumber(2, 4)
c = a + b
print(c)  # выводит "3 + 7i"

"""/////////////////////////////////*************************************////////////////////////////////////"""


# Статические методы

# не принимают никаких аргументов экземпляра или класса. Они определяются
# в самом классе, но не имеют доступа к переменным уровня класса или другим
# методам класса.

class MyClass:
    @staticmethod
    def static_method():
        print("This is a static method")


a = MyClass()
a.static_method()  # This is a static method

"""/////////////////////////////////*************************************////////////////////////////////////"""


# Метаклассы

# это класс, который определяет поведение других классов. В Python
# метакласс — это просто класс, который наследуется от класса типа. Метаклассы используются для динамического создания
# классов во время выполнения программы или для изменения поведения существующих классов.

class MyMeta(type):
    def __new__(cls, name, bases, attrs):
        attrs["my_attribute"] = 33
        return super().__new__(cls, name, bases, attrs)


class MyClass(metaclass=MyMeta):
    pass


print(MyClass.my_attribute)  # 33
print(
    MyClass.__dict__)  # {'__module__': '__main__', 'my_attribute': 33, '__dict__': <attribute '__dict__' of 'MyClass' objects>, '__weakref__': <attribute '__weakref__' of 'MyClass' objects>, '__doc__': None}

# В этом примере мы определяем метакласс MyMeta, который добавляет новый атрибут класса к любому классу,
# который его использует. Затем мы определяем новый класс под названием MyClass, который использует метакласс MyMeta,
# устанавливая его атрибут метакласса на MyMeta.

# Когда мы создаем экземпляр MyClass, он автоматически наследует атрибут класса my_attribute из своего метакласса.
# Затем мы можем получить доступ к значению атрибута, вызвав MyClass.my_attribute

"""/////////////////////////////////*************************************////////////////////////////////////"""


# Миксины

# это класс, предназначенный для добавления определенных свойств или атрибутов к другому классу.Миксин не предназначен
# для использования сам по себе, он нужен для смешивания с другим классом.В Python миксины реализованы как обычные
# классы, определяющие методы или атрибуты, которые могут быть добавлены к другим классам.

class LoggingMixin:
    def log(self, message):
        print(f"{self.__class__.__name__}: {message}")


class MyClass(LoggingMixin):
    def do_something(self):
        self.log("doing something")


"""/////////////////////////////////*************************************////////////////////////////////////"""


# Компоновщик

# это паттерн проектирования, который предполагает создание
# нового класса, содержащего экземпляр другого класса в качестве переменнойчлена. Затем новый class может использовать методы и атрибуты содержащегося
# в нем класса для реализации своего собственного поведения

class Engine:
    def start(self):
        print("engine started")


class Car:
    def __init__(self):
        self.engine = Engine()

    def start(self):
        self.engine.start()
        print("car started")


"""/////////////////////////////////*************************************////////////////////////////////////"""


# Утиная типизация и EAFP

# Идея заключается в том, что если объект ведет себя как утка, то это и есть утка, даже если на
# самом деле это не утка. Другими словами, при работе с объектами программист
# должен сосредоточиться на поведении объекта, а не на его типе или классе.

# Принцип EAFP (Easier to Ask for Forgiveness than Permission — «проще просить прощения, чем разрешения») связан с утиной типизацией и является
# распространенным способом работы с ошибками и исключениями в Python.
# Мы предполагаем, что операция завершится успешно, а затем обрабатываем все
# исключения, которые возникнут в противном случае

def my_function(obj):
    try:
        obj.quack()
    except AttributeError:
        print("This object does not quack!")


class Duck:
    def quack(self):
        print("Quack!")


class NotADuck:
    def bark(self):
        print("Woof!")


duck = Duck()
not_a_duck = NotADuck()
my_function(duck)  # Quack!
my_function(not_a_duck)  # This object does not quack!
#
# В этом примере мы определили функцию my_function, которая принимает объект в качестве аргумента и пытается
# вызвать метод quack. Если у объекта нет метода quack, будет вызвано исключение AttributeError, которое мы поймаем
# и обработаем, напечатав сообщение.

# Затем мы определяем два класса, Duck и NotADuck, которые имеют метод quack и метод bark соответственно.
# Мы создаем экземпляры этих классов и передаем их в качестве аргументов в функцию my_function.

# Когда мы вызываем функцию my_function с объектом duck, метод quack вызывается успешно и выводится сообщение Quack!.
# При вызове функции my_function с объектом not_a_duck метод quack не найден, поймано и обработано исключение
# AttributeError, в результате чего выводится сообщение This object does not quack!


"""/////////////////////////////////*************************************////////////////////////////////////"""


# Monkey patch и динамические классы

# Monkey patch подразумевает изменение существующего объекта или модуля во время выполнения путем замены или
# добавления методов или атрибутов.

# Динамические классы — это классы, которые создаются во время выполнения программы с помощью метаклассов или
# функции type()

# Пример Monkey patch


class MyClass:
    def say_hello(self):
        print("Hello, Master!")


def monkey_patch(self):
    print("Monkey patching the say_hello method")


MyClass.say_hello = monkey_patch
obj = MyClass()
obj.say_hello()  # Monkey patching the say_hello method


# В этом примере мы определяем класс MyClass с методом say_hello(). Затем определяем новую функцию monkey_patch(),
# которая будет заменять метод say_hello() при monkey patch класса. Наконец, мы исправляем метод say_hello()
# класса MyClass с помощью функции monkey_patch() и создаем экземпляр класса.

# Когда мы вызываем метод say_hello() на этом экземпляре, он теперь выводит Monkey patching the say_hello method


# Пример создания динамического класса во время выполнения с помощью функции type()

def make_class(name, base, attrs):
    return type(name, base, attrs)


MyClass = make_class("MyClass", (object,), {"say_hello": lambda self: print("Hello, Master!")})
obj = MyClass()
obj.say_hello()  # Hello, Master!

# Здесь мы определяем функцию make_class(), которая использует функцию type() для создания нового класса
# во время выполнения. Мы передаем имя класса, кортеж базовых классов (в данном случае просто object) и словарь
# атрибутов класса. Определяем метод say_hello() класса как лямбда-функцию, которая при вызове выводит Hello, Master!.
# Наконец, мы создаем экземпляр класса и вызываем его метод say_hello(), который выводит Hello, Master!

"""/////////////////////////////////*************************************////////////////////////////////////"""


# Метапрограммирование
# позволяет создавать программы, которые могут изменять свое поведение, часто динамически, во время выполнения


# Фабрика классов

# это функция, которая создает и возвращает новый класс. Она позволяет создавать новые классы с динамическими
# атрибутами и методами

def make_class(name, *args, **kwargs):
    class NewClass:
        def __init__(self):
            pass

        def __str__(self):
            return name

    return NewClass


# В этом примере make_class() — это функция, которая принимает аргумент имени и возвращает новый класс с этим именем.
# Класс имеет простой конструктор, который не принимает никаких аргументов, а также метод __str__(), который
# возвращает имя класса.

# Чтобы использовать фабрику классов, вызовем ее с аргументом name:

MyClass = make_class('MyClass')
print(MyClass())  # вывод: MyClass

# Этот код создает новый класс MyClass с методом __str__(), который возвращает имя класса


"""/////////////////////////////////*************************************////////////////////////////////////"""

# Рефлексия и интроспекция

# Рефлексия относится к способности программы проверять свою структуру и поведение во время выполнения, а благодаря
# интроспекции программа проверяет поведение и свойства объектов во время выполнения

# Один из ключевых механизмов в Python для интроспекции — функция dir().
# Она возвращает список всех атрибутов объекта, включая как атрибуты, определенные классом объекта, так и любые атрибуты, которые были динамически
# добавлены во время выполнения. Можно также использовать функцию type()
# для проверки типа объекта и функцию isinstance() — для проверки того, является ли объект экземпляром этого класса.
# Python также предоставляет ряд встроенных атрибутов, которые можно использовать для рефлексии, например атрибут __name__, который возвращает
# имя класса или функции, и атрибут __doc__, который возвращает строку документации класса или функции.

"""/////////////////////////////////*************************************////////////////////////////////////"""

