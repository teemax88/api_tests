"""Полиморфизм — это способность объекта принимать различные формы. В ООП
полиморфизм позволяет писать код, который может работать с объектами разных
классов, если они имеют общий интерфейс или базовый класс."""

# Перегрузка методов
# позволяет определить несколько методов с одинаковым именем, но разными параметрами
# class Math:
#     def add(self, a, b):
#         return a + b
#
#     def add(self, a, b, c):
#         return a + b + c


# Например, вы можете написать функцию, которая принимает в качестве
# аргумента объект класса Animal и вызывает метод speak на этом объекте. Затем
# вы можете передать в функцию объекты классов Dog и Cat, и в зависимости от
# типа переданного объекта будет вызван соответствующий метод speak.


# class Animal:
#     def speak(self):
#         print("The animal makes a sound")


# class Dog(Animal):
#     def speak(self):
#         print("The dog barks")


# class Cat(Animal):
#     def speak(self):
#         print("The cat meows")


# def make_sound(animal):
#     animal.speak()


# dog = Dog()
# cat = Cat()
# make_sound(dog)
# make_sound(cat)

"""/////////////////////////////////*************************************////////////////////////////////////"""

# Перегрузка операторов

# это возможность переопределения
# действий оператора при его применении к экземпляру класса. Например, если
# вы добавите пользовательский класс для представления комплексных чисел, то
# можете определить, что произойдет, когда оператор + будет использоваться для
# сложения двух экземпляров вашего класса

# Пример
# class ComplexNumber:
#     def __init__(self, real, imaginary):
#         self.real = real
#         self.imaginary = imaginary

# def __add__(self, other):
#     return ComplexNumber(self.real + other.real, self.imaginary + other.imaginary)

# def __str__(self):
#     return f"{self.real} + {self.imaginary}i"


# a = ComplexNumber(1, 3)
# b = ComplexNumber(2, 4)
# c = a + b
# print(c)  # выводит "3 + 7i"

"""/////////////////////////////////*************************************////////////////////////////////////"""

# Статические методы

# не принимают никаких аргументов экземпляра или класса. Они определяются
# в самом классе, но не имеют доступа к переменным уровня класса или другим
# методам класса.

# class MyClass:
#     @staticmethod
#     def static_method():
#         print("This is a static method")


# a = MyClass()
# a.static_method()  # This is a static method

"""/////////////////////////////////*************************************////////////////////////////////////"""

# Метаклассы

# это класс, который определяет поведение других классов. В Python
# метакласс — это просто класс, который наследуется от класса типа. Метаклассы используются для динамического создания
# классов во время выполнения программы или для изменения поведения существующих классов.

# class MyMeta(type):
#     def __new__(cls, name, bases, attrs):
#         attrs["my_attribute"] = 33
#         return super().__new__(cls, name, bases, attrs)


# class MyClass(metaclass=MyMeta):
#     pass


# print(MyClass.my_attribute)  # 33
# print(MyClass.__dict__)
# Вывод: {'__module__': '__main__', 'my_attribute': 33, '__dict__': <attribute '__dict__' of 'MyClass' objects>,
# '__weakref__': <attribute '__weakref__' of 'MyClass' objects>, '__doc__': None}

# В этом примере мы определяем метакласс MyMeta, который добавляет новый атрибут класса к любому классу,
# который его использует. Затем мы определяем новый класс под названием MyClass, который использует метакласс MyMeta,
# устанавливая его атрибут метакласса на MyMeta.

# Когда мы создаем экземпляр MyClass, он автоматически наследует атрибут класса my_attribute из своего метакласса.
# Затем мы можем получить доступ к значению атрибута, вызвав MyClass.my_attribute

"""/////////////////////////////////*************************************////////////////////////////////////"""

# Миксины

# это класс, предназначенный для добавления определенных свойств или атрибутов к другому классу.Миксин не предназначен
# для использования сам по себе, он нужен для смешивания с другим классом.В Python миксины реализованы как обычные
# классы, определяющие методы или атрибуты, которые могут быть добавлены к другим классам.

# class LoggingMixin:
#     def log(self, message):
#         print(f"{self.__class__.__name__}: {message}")


# class MyClass(LoggingMixin):
#     def do_something(self):
#         self.log("doing something")


"""/////////////////////////////////*************************************////////////////////////////////////"""

# Компоновщик

# это паттерн проектирования, который предполагает создание
# нового класса, содержащего экземпляр другого класса в качестве переменнойчлена. Затем новый class может использовать
# методы и атрибуты содержащегося
# в нем класса для реализации своего собственного поведения

# class Engine:
#     def start(self):
#         print("engine started")


# class Car:
#     def __init__(self):
#         self.engine = Engine()

# def start(self):
#     self.engine.start()
#     print("car started")


"""/////////////////////////////////*************************************////////////////////////////////////"""

# Утиная типизация и EAFP

# Идея заключается в том, что если объект ведет себя как утка, то это и есть утка, даже если на
# самом деле это не утка. Другими словами, при работе с объектами программист
# должен сосредоточиться на поведении объекта, а не на его типе или классе.

# Принцип EAFP (Easier to Ask for Forgiveness than Permission — «проще просить прощения, чем разрешения»)
# связан с утиной типизацией и является
# распространенным способом работы с ошибками и исключениями в Python.
# Мы предполагаем, что операция завершится успешно, а затем обрабатываем все
# исключения, которые возникнут в противном случае

# def my_function(obj):
#     try:
#         obj.quack()
#     except AttributeError:
#         print("This object does not quack!")


# class Duck:
#     def quack(self):
#         print("Quack!")


# class NotADuck:
#     def bark(self):
#         print("Woof!")


# duck = Duck()
# not_a_duck = NotADuck()
# my_function(duck)  # Quack!
# my_function(not_a_duck)  # This object does not quack!

# В этом примере мы определили функцию my_function, которая принимает объект в качестве аргумента и пытается
# вызвать метод quack. Если у объекта нет метода quack, будет вызвано исключение AttributeError, которое мы поймаем
# и обработаем, напечатав сообщение.

# Затем мы определяем два класса, Duck и NotADuck, которые имеют метод quack и метод bark соответственно.
# Мы создаем экземпляры этих классов и передаем их в качестве аргументов в функцию my_function.

# Когда мы вызываем функцию my_function с объектом duck, метод quack вызывается успешно и выводится сообщение Quack!.
# При вызове функции my_function с объектом not_a_duck метод quack не найден, поймано и обработано исключение
# AttributeError, в результате чего выводится сообщение This object does not quack!


"""/////////////////////////////////*************************************////////////////////////////////////"""

# Monkey patch и динамические классы

# Monkey patch подразумевает изменение существующего объекта или модуля во время выполнения путем замены или
# добавления методов или атрибутов.

# Динамические классы — это классы, которые создаются во время выполнения программы с помощью метаклассов или
# функции type()

# Пример Monkey patch


# class MyClass:
#     def say_hello(self):
#         print("Hello, Master!")


# def monkey_patch(self):
#     print("Monkey patching the say_hello method")


# MyClass.say_hello = monkey_patch
# obj = MyClass()
# obj.say_hello()  # Monkey patching the say_hello method


# В этом примере мы определяем класс MyClass с методом say_hello(). Затем определяем новую функцию monkey_patch(),
# которая будет заменять метод say_hello() при monkey patch класса. Наконец, мы исправляем метод say_hello()
# класса MyClass с помощью функции monkey_patch() и создаем экземпляр класса.

# Когда мы вызываем метод say_hello() на этом экземпляре, он теперь выводит Monkey patching the say_hello method


# Пример создания динамического класса во время выполнения с помощью функции type()

# def make_class(name, base, attrs):
#     return type(name, base, attrs)


# MyClass = make_class("MyClass", (object,), {"say_hello": lambda self: print("Hello, Master!")})
# obj = MyClass()
# obj.say_hello()  # Hello, Master!

# Здесь мы определяем функцию make_class(), которая использует функцию type() для создания нового класса
# во время выполнения. Мы передаем имя класса, кортеж базовых классов (в данном случае просто object) и словарь
# атрибутов класса. Определяем метод say_hello() класса как лямбда-функцию, которая при вызове выводит Hello, Master!.
# Наконец, мы создаем экземпляр класса и вызываем его метод say_hello(), который выводит Hello, Master!

"""/////////////////////////////////*************************************////////////////////////////////////"""

# Метапрограммирование
# позволяет создавать программы, которые могут изменять свое поведение, часто динамически, во время выполнения


# Фабрика классов

# это функция, которая создает и возвращает новый класс. Она позволяет создавать новые классы с динамическими
# атрибутами и методами

# def make_class(name, *args, **kwargs):
#     class NewClass:
#         def __init__(self):
#             pass

# def __str__(self):
#     return name

# return NewClass


# В этом примере make_class() — это функция, которая принимает аргумент имени и возвращает новый класс с этим именем.
# Класс имеет простой конструктор, который не принимает никаких аргументов, а также метод __str__(), который
# возвращает имя класса.

# Чтобы использовать фабрику классов, вызовем ее с аргументом name:

# MyClass = make_class('MyClass')
# print(MyClass())  # вывод: MyClass

# Этот код создает новый класс MyClass с методом __str__(), который возвращает имя класса


"""/////////////////////////////////*************************************////////////////////////////////////"""

# Рефлексия и интроспекция

# Рефлексия относится к способности программы проверять свою структуру и поведение во время выполнения, а благодаря
# интроспекции программа проверяет поведение и свойства объектов во время выполнения

# Один из ключевых механизмов в Python для интроспекции — функция dir().
# Она возвращает список всех атрибутов объекта, включая как атрибуты, определенные классом объекта,
# так и любые атрибуты, которые были динамически
# добавлены во время выполнения. Можно также использовать функцию type()
# для проверки типа объекта и функцию isinstance() — для проверки того, является ли объект экземпляром этого класса.
# Python также предоставляет ряд встроенных атрибутов, которые можно использовать для рефлексии, например
# атрибут __name__, который возвращает имя класса или функции, и атрибут __doc__, который возвращает строку
# документации класса или функции.

"""/////////////////////////////////*************************************////////////////////////////////////"""

# Регулярные выражения

# Регулярные выражения можно использовать для поиска шаблонов в строках с помощью функций
# re.search(), re.match() и re.findall().

# Например, символ точки . соответствует любому символу, кроме новой строки,
# символ каретки ^ соответствует началу строки, а знак доллара ($) — концу строки

# import re
#
# pattern = "Python"
# text = "Peter Severa loves programming in Python!"
# match = re.search(pattern, text)
# if match.start():
#     print("Found a match!")
# else:
#     print("No match")

# Вывод: Found a match!


# Если вы хотите искать специальные символы как литеральные, их нужно экранировать обратным слешем \.
# Например, если нужно найти в тексте литеральный символ $, тогда экранируйте его следующим образом: \$.
# Для поиска самого обратного слеша используйте выражение \\\.


# Классы символов, также известные как наборы символов, или диапазоны символов, используются для поиска любого символа
# из набора символов. Это достигается путем помещения набора символов в квадратные скобки [ ]
# Например, регулярное выражение [abc] соответствует любому из символов a, b или c.
# Аналогично, выражение [0123456789] соответствует любой из цифр от 0 до 9.

# Классы символов можно также использовать для сопоставления с любым символом, которого нет в наборе символов.
# Для этого используется символ каретки (^) в качестве первого символа внутри квадратных скобок
# Например, выражение [^abc] соответствует любому символу, который не является a, b или c.
# Аналогично, выражение [^0123456789] соответствует любому символу, который не является цифрой

# Классы символов можно также использовать для сопоставления диапазонов символов.
# Для этого нужно указать первый и последний символы в диапазоне, разделенные дефисом (-) внутри квадратных скобок
# Например, выражение [a-z] соответствует любой строчной букве от a до z, а выражение [A-Z] соответствует любой
# заглавной букве от A до Z. Регулярное выражение [0-9] соответствует любой цифре от 0 до 9.

# Основные классы символов
# [0-9] соответствует любой одной цифре;
# [a-z] соответствует любой строчной букве;
# [A-Z] соответствует любой прописной букве;
# [a-zA-Z] соответствует любой букве, как прописной, так и строчной;
# [aeiou] соответствует любой гласной.

# Классы символов можно также комбинировать с помощью символа (|) для соответствия любому из набора классов символов.
# Например, выражение [0-9]|[a-z] будет соответствовать любой одной цифре или строчной букве

# Обратите внимание, что важен порядок символов в диапазоне.
# Например, [a-z] соответствует любой строчной букве от a до z, а вот [z-a] не является допустимым диапазоном


# Сокращенные классы символов
# \d соответствует любой десятичной цифре (0–9);
# \D соответствует любому нецифровому символу;
# \s соответствует любому символу пробела (пробел, табуляция, новая строка и т. д.);
# \S соответствует любому символу, не являющемуся пробелом;
# \w соответствует любому буквенно-цифровому символу (a–z, A–Z, 0–9 и подчеркивание);
# \W соответствует символу, не являющемуся буквенным, цифровым или символом подчеркивания.

# Например, для поиска строки, которая начинается с цифры и за которой следуют две буквы,
# можно использовать шаблон \d\w\w. Он соответствует любой цифре, за которой следуют два буквенно-цифровых символа.

# Например, для поиска строки, начинающейся с нецифрового символа, можно использовать выражение ^\D.


# Вложенные классы символов — это классы символов, которые определены внутри другого класса символов.

# Например, если нужно выявить сопоставление с любой строчной буквой или цифрой, используйте следующее выражение:
# [a-z\d]
# Здесь внешний класс символов [ ] соответствует любому символу, который является либо строчной буквой, либо цифрой.
# Внутренний класс символов \d соответствует любой цифре.

# Квантификаторы и альтернация
# Квантификаторы позволяют указать, сколько раз шаблон должен встречаться во входной строке

# ? — совпадает с одним вхождением предшествующего шаблона или не совпадает ни с одним;
# * совпадает с одним или несколькими вхождениями предыдущего шаблона или не совпадает ни с одним;
# + совпадает с одним или несколькими вхождениями предыдущего шаблона;
# {m} — совпадает ровно с m вхождениями предыдущего шаблона;
# {m, n} — соответствует от m до n (включительно) вхождениям предыдущего шаблона

# Альтернация позволяет сопоставить один из нескольких шаблонов. Например, выражение cat|dog будет соответствовать
# либо cat, либо dog во входной строке. Символ | используется для разделения шаблонов в альтернации.
# Вы можете использовать круглые скобки, чтобы сгруппировать шаблоны и применить альтернацию к более крупному шаблону.
# Например, выражение (cat|dog)food будет соответствовать либо catfood, либо dogfood во входной строке

# Квантификаторы и альтернацию можно использовать вместе для создания более сложных регулярных выражений.
# Например, регулярное выражение a{2,3}|b{3} будет соответствовать либо aa, либо aaa, либо bbb во входной строке.

# Квантификатор звездочка (*) используется для соответствия нулю или более вхождений предыдущего символа или группы.
# Вот несколько примеров использования квантификатора *:
# ab*c соответствует ac, abc, abbc, abbbc и т. д.;
# a.*b соответствует ab, aXb, aXYb и т. д., где X и Y могут быть любыми символами;
# a.*?b является нежадной версией предыдущего примера и соответствует ab, aXb, aXYb и т. д., но останавливается
# на первом вхождении b.
# Важно отметить, что квантификатор * по умолчанию жадный, то есть он будет соответствовать максимальному
# количеству вхождений. Однако вы можете использовать нежадную версию (.*?), чтобы найти как можно меньше вхождений.

# Квантификатор + соответствует одному или нескольким вхождениям предыдущего символа или группы.
# Он похож на квантификатор *, но для его использования требуется хотя бы одно вхождение символа или группы.
# Например, регулярное выражение a+ соответствует одному или нескольким вхождениям буквы a.
# Оно будет соответствовать строкам a, aa, aaa и т. д., но не будет соответствовать пустой строке.

# import re
#
# string1 = "Число 333 11"
# string2 = "Число 33311"
# pattern = "\d+"
# result1 = re.search(pattern, string1)
# result2 = re.search(pattern, string2)
# if result1 or result2:
#     print(result1.group())  # вывод: 333
#     print(result2.group())  # вывод: 33311

# Квантификатор ? указывает на то, что предыдущий символ или группа необязательны.
# Он соответствует либо нулю, либо одному вхождению предыдущего символа или группы.

# Примеры:
# ab? соответствует либо a, либо ab;
# colou?r соответствует как color, так и colour;
# https? соответствует как http, так и https.

# Квантификатор ? можно также использовать для того, чтобы сделать другие квантификаторы ленивыми, а не жадными.
# Это означает, что они будут сопоставлять как можно меньше, а не как можно больше символов.

# Несколько примеров использования ленивого квантификатора ?:
# a+? соответствует одному или нескольким символам a, но только в том количестве, которое необходимо
# для нахождения совпадения;
# a*?b соответствует наименьшей возможной строке, которая начинается с нуля или более символов a и заканчивается
# символом b;
# a?? либо соответствует одному символу a, либо не соответствует ни одному.
